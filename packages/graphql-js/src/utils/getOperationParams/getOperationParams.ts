import type {
  BaseGeneratedSchema,
  OperationArgs,
  OperationField,
  OperationParam,
} from '../../client/client.types'

export interface GetOperationParamsOptions {
  /**
   * The name of the field.
   */
  field: OperationField
  /**
   * Type of the operation.
   */
  operationType: 'query' | 'mutation'
  /**
   * The generated schema.
   */
  generatedSchema: BaseGeneratedSchema
  /**
   * Arguments passed to the query.
   */
  args?: OperationArgs
}

/**
 * Returns all the parameters for an operation based on the selected fields.
 *
 * @param options - Options to configure the parameters.
 * @returns The parameters for the operation.
 */
export default function getOperationParams({
  generatedSchema,
  args,
  field,
  operationType,
}: GetOperationParamsOptions): OperationParam[] {
  if (!args) {
    return []
  }

  const currentParams: OperationParam[] = Object.keys(args.variables || {}).map(
    (variable) => ({
      name: variable,
      path: field.name,
      type:
        generatedSchema?.[operationType]?.[field.name].__args?.[variable] ||
        field.type,
    }),
  )

  const nestedParams: OperationParam[] = Object.keys(args.select || {})
    .filter((key) => typeof args.select?.[key] !== 'boolean')
    .map((key) =>
      getOperationParams({
        generatedSchema,
        args: args.select?.[key] as OperationArgs,
        field: {
          name: key,
          type: '', // Unknown at this point, will be generated by the recursive call
        },
        operationType,
      }).map((param) => ({
        ...param,
        path: `${field.name}.${param.path}`,
      })),
    )
    .reduce(
      (variables, currentVariables) => [...variables, ...currentVariables],
      [],
    )

  return [...currentParams, ...nestedParams]
}
